# Техническое задание (ТЗ) на создание бэкенда для мобильного приложения с интеграцией RuStore

## 1. Общая информация
### 1.1. Назначение
Бэкенд представляет собой серверную часть системы, обеспечивающую обработку запросов от мобильного приложения (Android) и web-фронтенда. Основные функции: верификация платежей и покупок через RuStore, управление пользователями, подписками и поинтами (виртуальной валютой для генерации ИИ-контента, такого как поздравления и открытки). Бэкенд интегрируется с API RuStore для безопасной обработки транзакций, предотвращения мошенничества и синхронизации данных. Это стандартный подход для приложений с монетизацией, как в сервисах типа Duolingo или Calm, где сервер проверяет покупки и управляет аккаунтами.

### 1.2. Цели
- **Безопасность**: Верификация всех транзакций на сервере, чтобы избежать подделок на клиенте.
- **Управление данными**: Хранение и обновление информации о пользователях, подписках и поинтах в реальном времени.
- **Интеграция**: Поддержка вебхуков от RuStore для автоматических обновлений (например, при отмене подписки).
- **Масштабируемость**: Поддержка до 10k+ активных пользователей, с возможностью горизонтального масштабирования.
- **API для фронтенда и мобильного app**: RESTful endpoints для чтения/записи данных.

### 1.3. Предполагаемые технологии
- **Язык/Фреймворк**: Node.js с Express.js (для простоты и скорости) или Python с FastAPI (для асинхронности).
- **База данных**: PostgreSQL (реляционная, для транзакций) или MongoDB (NoSQL, для гибкости).
- **Аутентификация**: JWT (JSON Web Tokens) для сессий, с refresh tokens.
- **Интеграция с RuStore**: Использование RuStore API (HTTPS запросы для верификации, подтверждения и отмены покупок).
- **Кэширование**: Redis для временных данных (балансы, сессии).
- **Очереди**: RabbitMQ или Bull для асинхронной обработки (например, верификации).
- **Логирование и мониторинг**: Winston/Sentry для логов, Prometheus для метрик.
- **Хостинг**: Heroku, AWS EC2 или DigitalOcean; Docker для контейнеризации.
- **Дополнительно**: Environment variables для ключей (RuStore publicKey, secret), HTTPS enforced.

## 2. Функциональные требования
### 2.1. Аутентификация и пользователи
- **Регистрация**: POST /api/auth/register — Принимает email, password, deviceId (из app). Создаёт пользователя в БД, хэширует пароль (bcrypt). Возвращает JWT.
- **Вход**: POST /api/auth/login — Проверяет credentials, возвращает JWT. Опционально: OAuth интеграция (VK/Google).
- **Профиль**: GET /api/user/profile (с JWT) — Возвращает данные: userId, email, баланс поинтов, статус подписки.
- **Обновление**: PATCH /api/user/update — Изменение пароля/email.

### 2.2. Интеграция с RuStore (Платежи и верификация)
- **Верификация покупки**: POST /api/payments/verify — Принимает purchaseId, orderId, productId от app. Вызывает RuStore API (GET /purchases/{purchaseId}) для проверки статуса (PAID). Если OK — подтверждает (POST /purchases/confirm), обновляет БД (добавляет поинты или активирует подписку). Возвращает success/failure.
- **Верификация подписки**: POST /api/subscriptions/verify — Аналогично, но для subscriptionToken. Проверяет статус (active/expired) через RuStore API.
- **Webhooks**: POST /api/webhooks/rustore — Эндпоинт для уведомлений от RuStore (настроить в консоли RuStore). Обработка событий: subscription_renewed, subscription_cancelled, purchase_confirmed. Обновляет БД асинхронно.
- **Получение продуктов**: GET /api/products — Кэширует и возвращает список продуктов/цен из RuStore (для синхронизации с app).

### 2.3. Управление подписками
- **Статус**: GET /api/subscriptions/status (с JWT) — Возвращает детали: plan (monthly/yearly), startDate, endDate, status (active/cancelled).
- **Оформление**: POST /api/subscriptions/create — Инициирует подписку (redirect или token для app), но основная логика в app; сервер только верифицирует.
- **Отмена**: POST /api/subscriptions/cancel — Вызывает RuStore API для отмены, обновляет БД.
- **Продление**: POST /api/subscriptions/renew — Ручное продление (если нужно), через верификацию новой покупки.

### 2.4. Управление поинтами
- **Баланс**: GET /api/points/balance (с JWT) — Возвращает текущий баланс.
- **Покупка**: POST /api/points/buy — После верификации покупки добавляет поинты (например, +100 за productId "points_100").
- **Расход**: POST /api/points/spend — Принимает amount (например, 1 за генерацию), проверяет баланс, вычитает. Если <0 — error.
- **История**: GET /api/points/history — Список транзакций (дата, тип: buy/spend, amount).

### 2.5. Интеграция с ИИ (опционально)
- Если app использует ИИ для генерации (например, API OpenAI), то: POST /api/generation/request — Проверяет поинты, вычитает, вызывает ИИ API, возвращает результат.

## 3. Нефункциональные требования
- **Производительность**: Response time < 200ms для 95% запросов; rate limiting (100 req/min per IP).
- **Безопасность**: HTTPS, CORS (только для app/web доменов), input validation (Joi или Pydantic), SQL injection protection.
- **Ошибки**: Стандартизированные responses (e.g., {error: "Invalid purchase", code: 400}).
- **Логи**: Log all API calls, errors; интеграция с ELK stack.
- **Тестирование**: Unit tests (Jest/Pytest) >80% coverage; E2E tests для ключевых flows (верификация).
- **Документация**: Swagger/OpenAPI для API docs.
- **Бэкапы**: Daily DB backups.

## 4. Этапы разработки
1. **Setup**: Инициализация проекта, настройка БД, env.
2. **Auth & Users**: Базовые эндпоинты.
3. **RuStore Integration**: Верификация, webhooks.
4. **Subscriptions & Points**: Логика управления.
5. **Testing & Deploy**: Тесты, деплой на хостинг.

## 5. Приложения
- Доки RuStore API: https://www.rustore.ru/help/api.
- Пример: Аналогично backend для Stripe в SaaS-приложениях.
- Бюджет/сроки: [Указать позже].